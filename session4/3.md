Helpful Reminders:

Verifying Signatures
>>> from pycoin.ecdsa import generator_secp256k1 as g
>>> n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141
>>> z = 0x524c14a77b666d906fbe56973becf3b3b9eac65442774473c68407e89c5659de
>>> r = 0xc0824a3ccdf3482f1435ef1917fad4a1d5573a15f0fa18a9b81dc76a941c4a3c
>>> s = 0x84ada30118411ef3f1777690d3dc182c289e04486375e91ba73bc48c51c59da7
>>> pub = g.__class__(g.curve(), 0xe493dbf1c10d80f3581e4904930b1404cc6c13900ee0758474fa94abe8c4cd13, 0x51ed993ea0d455b75642e2098ea51448d967ae33bfbdfe40cfe97bdc47739922)
>>> u = z * pow(s, n-2, n) % n
>>> v = r * pow(s, n-2, n) % n
>>> (u*g + v*pub).pair()[0] == r
True

Deriving public key from compressed SEC key
>>> x = 0x49fc4e631e3624a545de3f89f5d8684c7b8138bd94bdd531d2e213bf016b278a
>>> from pycoin.ecdsa import generator_secp256k1 as g
>>> from pycoin.ecdsa import public_pair_for_x
>>> y = public_pair_for_x(g, x, is_even=False)[1]
>>> pub = g.__class__(g.curve(), x, y)

1. Validate the signature for the first input in this transaction.

01000000012f5ab4d2666744a44864a63162060c2ae36ab0a2375b1c2b6b43077ed5dcbed6000000006a473044022034177d53fcb8e8cba62432c5f6cc3d11c16df1db0bce20b874cfc61128b529e1022040c2681a2845f5eb0c46adb89585604f7bf8397b82db3517afb63f8e3d609c990121035e8b10b675477614809f3dde7fd0e33fb898af6d86f51a65a54c838fddd417a5feffffff02c5872e00000000001976a91441b835c78fb1406305727d8925ff315d90f9bbc588acae2e1700000000001976a914c300e84d277c6c7bcf17190ebc4e7744609f8b0c88ac31470600


